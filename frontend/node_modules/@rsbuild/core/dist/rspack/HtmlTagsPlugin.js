"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var HtmlTagsPlugin_exports = {};
__export(HtmlTagsPlugin_exports, {
  FILE_ATTRS: () => FILE_ATTRS,
  HEAD_TAGS: () => HEAD_TAGS,
  HtmlTagsPlugin: () => HtmlTagsPlugin,
  VOID_TAGS: () => VOID_TAGS
});
module.exports = __toCommonJS(HtmlTagsPlugin_exports);
var import_shared = require("@rsbuild/shared");
var import_htmlPluginUtil = require("../provider/htmlPluginUtil");
const VOID_TAGS = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
const HEAD_TAGS = [
  "title",
  "base",
  "link",
  "style",
  "meta",
  "script",
  "noscript",
  "template"
];
const FILE_ATTRS = {
  link: "href",
  script: "src"
};
const withHash = (url, hash) => `${url}?${hash}`;
class HtmlTagsPlugin {
  constructor(opts) {
    this.name = "HtmlTagsPlugin";
    this.meta = { plugin: this.name };
    this.ctx = {
      append: true,
      ...opts
    };
  }
  apply(compiler) {
    compiler.hooks.compilation.tap(this.name, (compilation) => {
      const compilationHash = compilation.hash || "";
      const hooks = (0, import_htmlPluginUtil.getHTMLPlugin)().getHooks(compilation);
      hooks.alterAssetTagGroups.tap(this.name, (params) => {
        const includesCurrentFile = !this.ctx.includes || this.ctx.includes.includes(params.outputName);
        if (!includesCurrentFile || !this.ctx.tags?.length) {
          return params;
        }
        const fromWebpackTags = (tags2, override) => {
          const ret = [];
          for (const tag of tags2) {
            ret.push({
              tag: tag.tagName,
              attrs: tag.attributes,
              children: tag.innerHTML,
              publicPath: false,
              ...override
            });
          }
          return ret;
        };
        const fromInjectTags = (tags2) => {
          const ret = [];
          for (const tag of tags2) {
            const attrs = { ...tag.attrs };
            const filenameTag = FILE_ATTRS[tag.tag];
            let filename = attrs[filenameTag];
            if (typeof filename === "string") {
              const optPublicPath = tag.publicPath ?? this.ctx.publicPath;
              if (typeof optPublicPath === "function") {
                filename = optPublicPath(filename, params.publicPath);
              } else if (typeof optPublicPath === "string") {
                filename = (0, import_shared.withPublicPath)(filename, optPublicPath);
              } else if (optPublicPath !== false) {
                filename = (0, import_shared.withPublicPath)(filename, params.publicPath);
              }
              const optHash = tag.hash ?? this.ctx.hash;
              if (typeof optHash === "function") {
                compilationHash.length && (filename = optHash(filename, compilationHash));
              } else if (typeof optHash === "string") {
                optHash.length && (filename = withHash(filename, optHash));
              } else if (optHash === true) {
                compilationHash.length && (filename = withHash(filename, compilationHash));
              }
              attrs[filenameTag] = filename;
            }
            ret.push({
              tagName: tag.tag,
              attributes: attrs,
              meta: this.meta,
              voidTag: VOID_TAGS.includes(tag.tag),
              innerHTML: tag.children
            });
          }
          return ret;
        };
        const handlers = [];
        let tags = [
          ...fromWebpackTags(params.headTags, { head: true }),
          ...fromWebpackTags(params.bodyTags, { head: false })
        ];
        this.ctx.tags.forEach((tag) => {
          if ((0, import_shared.isFunction)(tag)) {
            handlers.push(tag);
          } else {
            tags.push(tag);
          }
        });
        const getPriority = (tag) => {
          const head = tag.head ?? HEAD_TAGS.includes(tag.tag);
          let priority = head ? -2 : 2;
          const append = tag.append ?? this.ctx.append;
          if (typeof append === "boolean") {
            priority += append ? 1 : -1;
          }
          return priority;
        };
        tags = tags.sort((tag1, tag2) => getPriority(tag1) - getPriority(tag2));
        const utils = {
          outputName: params.outputName,
          publicPath: params.publicPath,
          hash: compilationHash
        };
        for (const handler of handlers) {
          tags = handler(tags, utils) || tags;
        }
        const [headTags, bodyTags] = (0, import_shared.partition)(
          tags,
          (tag) => tag.head ?? HEAD_TAGS.includes(tag.tag)
        );
        params.headTags = fromInjectTags(headTags);
        params.bodyTags = fromInjectTags(bodyTags);
        return params;
      });
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FILE_ATTRS,
  HEAD_TAGS,
  HtmlTagsPlugin,
  VOID_TAGS
});

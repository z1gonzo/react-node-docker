"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var devServer_exports = {};
__export(devServer_exports, {
  getServerAPIs: () => getServerAPIs,
  startDevServer: () => startDevServer
});
module.exports = __toCommonJS(devServer_exports);
var import_shared = require("@rsbuild/shared");
var import_helper = require("./helper");
var import_connect = __toESM(require("@rsbuild/shared/connect"));
var import_restart = require("./restart");
var import_httpServer = require("./httpServer");
var import_getDevMiddlewares = require("./getDevMiddlewares");
var import_middlewares = require("./middlewares");
async function getServerAPIs(options, createDevMiddleware, {
  compiler: customCompiler,
  getPortSilently
} = {}) {
  if (!process.env.NODE_ENV) {
    process.env.NODE_ENV = "development";
  }
  const rsbuildConfig = options.context.config;
  const { devServerConfig, port, host, https } = await (0, import_helper.getDevOptions)({
    rsbuildConfig,
    getPortSilently
  });
  const defaultRoutes = (0, import_helper.formatRoutes)(
    options.context.entry,
    rsbuildConfig.output?.distPath?.html,
    rsbuildConfig.html?.outputStructure
  );
  options.context.devServer = {
    hostname: host,
    port,
    https
  };
  return {
    config: { devServerConfig, port, host, https, defaultRoutes },
    beforeStart: async () => {
      await options.context.hooks.onBeforeStartDevServerHook.call();
    },
    afterStart: async (params = {}) => {
      await options.context.hooks.onAfterStartDevServerHook.call({
        port: params.port || port,
        routes: params.routes || defaultRoutes
      });
    },
    startCompile: async () => {
      const { devMiddleware, compiler } = await createDevMiddleware(
        options,
        customCompiler
      );
      const { CompilerDevMiddleware } = await Promise.resolve().then(() => __toESM(require("./compilerDevMiddleware")));
      const publicPaths = compiler.compilers ? compiler.compilers.map(
        import_shared.getPublicPathFromCompiler
      ) : [(0, import_shared.getPublicPathFromCompiler)(compiler)];
      const compilerDevMiddleware = new CompilerDevMiddleware({
        dev: devServerConfig,
        publicPaths,
        devMiddleware
      });
      compilerDevMiddleware.init();
      return {
        middleware: compilerDevMiddleware.middleware,
        sockWrite: (...args) => compilerDevMiddleware.sockWrite(...args),
        onUpgrade: (...args) => compilerDevMiddleware.upgrade(...args),
        close: () => compilerDevMiddleware?.close()
      };
    },
    getMiddlewares: async (params = {}) => {
      const { compileMiddlewareAPI, overrides = {} } = params;
      return (0, import_getDevMiddlewares.getMiddlewares)({
        pwd: options.context.rootPath,
        compileMiddlewareAPI,
        dev: {
          ...devServerConfig,
          ...overrides
        },
        output: {
          distPath: rsbuildConfig.output?.distPath?.root || import_shared.ROOT_DIST_DIR
        }
      });
    }
  };
}
async function startDevServer(options, createDevMiddleware, {
  compiler,
  printURLs = true,
  logger: customLogger,
  getPortSilently
} = {}) {
  (0, import_shared.debug)("create dev server");
  const serverAPIs = await getServerAPIs(options, createDevMiddleware, {
    compiler,
    printURLs,
    logger: customLogger,
    getPortSilently
  });
  const {
    config: { devServerConfig, port, host, https, defaultRoutes }
  } = serverAPIs;
  const logger = customLogger ?? import_shared.logger;
  const middlewares = (0, import_connect.default)();
  const httpServer = await (0, import_httpServer.createHttpServer)({
    https: devServerConfig.https,
    middlewares
  });
  (0, import_shared.debug)("create dev server done");
  const protocol = https ? "https" : "http";
  let urls = (0, import_shared.getAddressUrls)(protocol, port, host);
  if (printURLs) {
    if ((0, import_shared.isFunction)(printURLs)) {
      urls = printURLs(urls);
      if (!Array.isArray(urls)) {
        throw new Error("Please return an array in the `printURLs` function.");
      }
    }
    (0, import_helper.printServerURLs)({
      urls,
      port,
      routes: defaultRoutes,
      logger,
      protocol,
      printUrls: devServerConfig.printUrls
    });
  }
  const compileMiddlewareAPI = await serverAPIs.startCompile();
  const devMiddlewares = await serverAPIs.getMiddlewares({
    compileMiddlewareAPI
  });
  devMiddlewares.middlewares.forEach((m) => middlewares.use(m));
  middlewares.use(import_middlewares.notFoundMiddleware);
  await serverAPIs.beforeStart();
  (0, import_shared.debug)("listen dev server");
  httpServer.on("upgrade", devMiddlewares.onUpgrade);
  return new Promise((resolve) => {
    httpServer.listen(
      {
        host,
        port
      },
      async (err) => {
        if (err) {
          throw err;
        }
        (0, import_shared.debug)("listen dev server done");
        await serverAPIs.afterStart();
        const closeServer = async () => {
          await devMiddlewares.close();
          httpServer.close();
        };
        (0, import_restart.onBeforeRestartServer)(closeServer);
        resolve({
          port,
          urls: urls.map((item) => item.url),
          server: {
            close: closeServer
          }
        });
      }
    );
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getServerAPIs,
  startDevServer
});

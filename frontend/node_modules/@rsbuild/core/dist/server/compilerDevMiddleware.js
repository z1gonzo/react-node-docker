"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var compilerDevMiddleware_exports = {};
__export(compilerDevMiddleware_exports, {
  CompilerDevMiddleware: () => CompilerDevMiddleware
});
module.exports = __toCommonJS(compilerDevMiddleware_exports);
var import_socketServer = require("./socketServer");
const noop = () => {
};
function getHMRClientPath(client) {
  const protocol = client?.protocol ? `&protocol=${client.protocol}` : "";
  const host = client?.host ? `&host=${client.host}` : "";
  const path = client?.path ? `&path=${client.path}` : "";
  const port = client?.port ? `&port=${client.port}` : "";
  const clientEntry = `${require.resolve("@rsbuild/core/client/hmr")}?${host}${path}${port}${protocol}`;
  return clientEntry;
}
class CompilerDevMiddleware {
  constructor({ dev, devMiddleware, publicPaths }) {
    this.devOptions = dev;
    this.publicPaths = publicPaths;
    this.socketServer = new import_socketServer.SocketServer(dev);
    this.devMiddleware = devMiddleware;
  }
  init() {
    this.middleware = this.setupDevMiddleware(
      this.devMiddleware,
      this.publicPaths
    );
    this.socketServer.prepare();
  }
  upgrade(req, sock, head) {
    this.socketServer.upgrade(req, sock, head);
  }
  close() {
    this.socketServer.close();
    this.middleware?.close(noop);
  }
  sockWrite(type, data) {
    this.socketServer.sockWrite(type, data);
  }
  setupDevMiddleware(devMiddleware, publicPaths) {
    const { devOptions } = this;
    const callbacks = {
      onInvalid: () => {
        this.socketServer.sockWrite("invalid");
      },
      onDone: (stats) => {
        this.socketServer.updateStats(stats);
      }
    };
    const injectClient = this.devOptions.hmr || this.devOptions.liveReload;
    const middleware = devMiddleware({
      headers: devOptions.headers,
      publicPath: "/",
      stats: false,
      callbacks,
      hmrClientPath: injectClient ? getHMRClientPath(devOptions.client) : void 0,
      serverSideRender: true,
      writeToDisk: devOptions.writeToDisk
    });
    const warp = async (req, res, next) => {
      const { url } = req;
      const assetPrefix = url && publicPaths.find((prefix) => url.startsWith(prefix));
      if (assetPrefix && assetPrefix !== "/") {
        req.url = url.slice(assetPrefix.length - 1);
        middleware(req, res, (...args) => {
          req.url = url;
          next(...args);
        });
      } else {
        middleware(req, res, next);
      }
    };
    warp.close = middleware.close;
    return warp;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CompilerDevMiddleware
});

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Compilation_inner;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compilation = void 0;
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/Compilation.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
const tapable = __importStar(require("tapable"));
const ChunkGroup_1 = require("./ChunkGroup");
const ErrorHelpers_1 = __importDefault(require("./ErrorHelpers"));
const Logger_1 = require("./logging/Logger");
const NormalModule_1 = require("./NormalModule");
const Stats_1 = require("./Stats");
const StatsFactory_1 = require("./stats/StatsFactory");
const StatsPrinter_1 = require("./stats/StatsPrinter");
const util_1 = require("./util");
const createSource_1 = require("./util/createSource");
const fake_1 = require("./util/fake");
const normalization_1 = require("./util/normalization");
const MergeCaller_1 = __importDefault(require("./util/MergeCaller"));
const Chunk_1 = require("./Chunk");
const ChunkGraph_1 = require("./ChunkGraph");
class Compilation {
    constructor(compiler, inner) {
        _Compilation_inner.set(this, void 0);
        this.childrenCounters = {};
        this.children = [];
        this.fileSystemInfo = {
            createSnapshot() {
                // fake implement to support html-webpack-plugin
                return null;
            }
        };
        this.fileDependencies = (0, fake_1.createFakeCompilationDependencies)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").getFileDependencies(), d => __classPrivateFieldGet(this, _Compilation_inner, "f").addFileDependencies(d));
        this.contextDependencies = (0, fake_1.createFakeCompilationDependencies)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").getContextDependencies(), d => __classPrivateFieldGet(this, _Compilation_inner, "f").addContextDependencies(d));
        this.missingDependencies = (0, fake_1.createFakeCompilationDependencies)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").getMissingDependencies(), d => __classPrivateFieldGet(this, _Compilation_inner, "f").addMissingDependencies(d));
        this.buildDependencies = (0, fake_1.createFakeCompilationDependencies)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").getBuildDependencies(), d => __classPrivateFieldGet(this, _Compilation_inner, "f").addBuildDependencies(d));
        this._rebuildModuleCaller = new MergeCaller_1.default((args) => {
            __classPrivateFieldGet(this, _Compilation_inner, "f").rebuildModule(args.map(item => item[0]), function (err, modules) {
                for (const [id, callback] of args) {
                    const m = modules.find(item => item.moduleIdentifier === id);
                    if (m) {
                        callback(err, m);
                    }
                    else {
                        callback(err || new Error("module no found"), null);
                    }
                }
            });
        }, 10);
        this.name = undefined;
        this.startTime = undefined;
        this.endTime = undefined;
        const processAssetsHooks = (0, fake_1.createFakeProcessAssetsHook)(this);
        this.hooks = {
            processAssets: processAssetsHooks,
            // TODO: webpack 6 deprecate, keep it just for compatibility
            /** @deprecated */
            additionalAssets: (0, fake_1.createProcessAssetsHook)(processAssetsHooks, "additionalAssets", Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL, () => []),
            childCompiler: new tapable.SyncHook([
                "childCompiler",
                "compilerName",
                "compilerIndex"
            ]),
            log: new tapable.SyncBailHook(["origin", "logEntry"]),
            optimizeModules: new tapable.SyncBailHook(["modules"]),
            afterOptimizeModules: new tapable.SyncBailHook(["modules"]),
            optimizeTree: new tapable.AsyncSeriesBailHook(["chunks", "modules"]),
            optimizeChunkModules: new tapable.AsyncSeriesBailHook([
                "chunks",
                "modules"
            ]),
            finishModules: new tapable.AsyncSeriesHook(["modules"]),
            chunkAsset: new tapable.SyncHook(["chunk", "filename"]),
            processWarnings: new tapable.SyncWaterfallHook(["warnings"]),
            succeedModule: new tapable.SyncHook(["module"]),
            stillValidModule: new tapable.SyncHook(["module"]),
            statsFactory: new tapable.SyncHook(["statsFactory", "options"]),
            statsPrinter: new tapable.SyncHook(["statsPrinter", "options"]),
            buildModule: new tapable.SyncHook(["module"]),
            executeModule: new tapable.SyncHook(["options", "context"])
        };
        this.compiler = compiler;
        this.resolverFactory = compiler.resolverFactory;
        this.inputFileSystem = compiler.inputFileSystem;
        this.options = compiler.options;
        this.outputOptions = compiler.options.output;
        this.logging = new Map();
        this.chunkGraph = new ChunkGraph_1.ChunkGraph(this);
        __classPrivateFieldSet(this, _Compilation_inner, inner, "f");
        // Cache the current NormalModuleHooks
    }
    get currentNormalModuleHooks() {
        return NormalModule_1.NormalModule.getCompilationHooks(this);
    }
    get hash() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").hash;
    }
    get fullHash() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").hash;
    }
    /**
     * Get a map of all assets.
     *
     * Source: [assets](https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L1008-L1009)
     */
    get assets() {
        return new Proxy({}, {
            get: (_, property) => {
                if (typeof property === "string") {
                    return this.__internal__getAssetSource(property);
                }
            },
            set: (target, p, newValue, receiver) => {
                if (typeof p === "string") {
                    this.__internal__setAssetSource(p, newValue);
                    return true;
                }
                return false;
            },
            deleteProperty: (target, p) => {
                if (typeof p === "string") {
                    this.__internal__deleteAssetSource(p);
                    return true;
                }
                return false;
            },
            has: (_, property) => {
                if (typeof property === "string") {
                    return this.__internal__hasAsset(property);
                }
                return false;
            },
            ownKeys: _ => {
                return this.__internal__getAssetFilenames();
            },
            getOwnPropertyDescriptor() {
                // To work with `Object.keys`, you should mark the property as enumerable.
                // See: https://262.ecma-international.org/7.0/#sec-enumerableownnames
                return {
                    enumerable: true,
                    configurable: true
                };
            }
        });
    }
    /**
     * Get a map of all entrypoints.
     */
    get entrypoints() {
        return new Map(Object.entries(__classPrivateFieldGet(this, _Compilation_inner, "f").entrypoints).map(([n, e]) => [
            n,
            ChunkGroup_1.ChunkGroup.__from_binding(e, __classPrivateFieldGet(this, _Compilation_inner, "f"))
        ]));
    }
    getCache(name) {
        return this.compiler.getCache(name);
    }
    createStatsOptions(optionsOrPreset, context = {}) {
        optionsOrPreset = (0, Stats_1.normalizeStatsPreset)(optionsOrPreset);
        let options = {};
        if (typeof optionsOrPreset === "object" && optionsOrPreset !== null) {
            options = Object.assign({}, optionsOrPreset);
        }
        const all = options.all;
        const optionOrLocalFallback = (v, def) => v !== undefined ? v : all !== undefined ? all : def;
        options.assets = optionOrLocalFallback(options.assets, true);
        options.chunks = optionOrLocalFallback(options.chunks, !context.forToString);
        options.chunkModules = optionOrLocalFallback(options.chunkModules, !context.forToString);
        options.chunkRelations = optionOrLocalFallback(options.chunkRelations, !context.forToString);
        options.modules = optionOrLocalFallback(options.modules, true);
        options.runtimeModules = optionOrLocalFallback(options.runtimeModules, !context.forToString);
        options.reasons = optionOrLocalFallback(options.reasons, !context.forToString);
        options.entrypoints = optionOrLocalFallback(options.entrypoints, true);
        options.chunkGroups = optionOrLocalFallback(options.chunkGroups, !context.forToString);
        options.errors = optionOrLocalFallback(options.errors, true);
        options.errorsCount = optionOrLocalFallback(options.errorsCount, true);
        options.warnings = optionOrLocalFallback(options.warnings, true);
        options.warningsCount = optionOrLocalFallback(options.warningsCount, true);
        options.hash = optionOrLocalFallback(options.hash, true);
        options.version = optionOrLocalFallback(options.version, true);
        options.publicPath = optionOrLocalFallback(options.publicPath, true);
        options.outputPath = optionOrLocalFallback(options.outputPath, !context.forToString);
        options.timings = optionOrLocalFallback(options.timings, true);
        options.builtAt = optionOrLocalFallback(options.builtAt, !context.forToString);
        options.moduleAssets = optionOrLocalFallback(options.moduleAssets, true);
        options.nestedModules = optionOrLocalFallback(options.nestedModules, !context.forToString);
        options.source = optionOrLocalFallback(options.source, false);
        options.logging = optionOrLocalFallback(options.logging, context.forToString ? "info" : true);
        options.loggingTrace = optionOrLocalFallback(options.loggingTrace, !context.forToString);
        options.loggingDebug = []
            .concat((0, Stats_1.optionsOrFallback)(options.loggingDebug, []))
            .map(Stats_1.normalizeFilter);
        options.modulesSpace =
            options.modulesSpace || (context.forToString ? 15 : Infinity);
        options.ids = optionOrLocalFallback(options.ids, !context.forToString);
        options.children = optionOrLocalFallback(options.children, !context.forToString);
        return options;
    }
    createStatsFactory(options) {
        const statsFactory = new StatsFactory_1.StatsFactory();
        this.hooks.statsFactory.call(statsFactory, options);
        return statsFactory;
    }
    createStatsPrinter(options) {
        const statsPrinter = new StatsPrinter_1.StatsPrinter();
        this.hooks.statsPrinter.call(statsPrinter, options);
        return statsPrinter;
    }
    /**
     * Update an existing asset. Trying to update an asset that doesn't exist will throw an error.
     *
     * See: [Compilation.updateAsset](https://webpack.js.org/api/compilation-object/#updateasset)
     * Source: [updateAsset](https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L4320)
     *
     * FIXME: *AssetInfo* may be undefined in update fn for webpack impl, but still not implemented in rspack
     *
     * @param {string} file file name
     * @param {Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new
     * @param {AssetInfo | function(AssetInfo): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new
     */
    updateAsset(filename, newSourceOrFunction, assetInfoUpdateOrFunction) {
        let compatNewSourceOrFunction;
        if (typeof newSourceOrFunction === "function") {
            compatNewSourceOrFunction = function newSourceFunction(source) {
                return (0, createSource_1.createRawFromSource)(newSourceOrFunction((0, createSource_1.createSourceFromRaw)(source)));
            };
        }
        else {
            compatNewSourceOrFunction = (0, createSource_1.createRawFromSource)(newSourceOrFunction);
        }
        __classPrivateFieldGet(this, _Compilation_inner, "f").updateAsset(filename, compatNewSourceOrFunction, typeof assetInfoUpdateOrFunction === "function"
            ? jsAssetInfo => (0, util_1.toJsAssetInfo)(assetInfoUpdateOrFunction(jsAssetInfo))
            : (0, util_1.toJsAssetInfo)(assetInfoUpdateOrFunction));
    }
    /**
     *
     * @param moduleIdentifier moduleIdentifier of the module you want to modify
     * @param source
     * @returns true if the setting is success, false if failed.
     */
    setNoneAstModuleSource(moduleIdentifier, source) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").setNoneAstModuleSource(moduleIdentifier, source);
    }
    /**
     * Emit an not existing asset. Trying to emit an asset that already exists will throw an error.
     *
     * See: [Compilation.emitAsset](https://webpack.js.org/api/compilation-object/#emitasset)
     * Source: [emitAsset](https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L4239)
     *
     * @param {string} file file name
     * @param {Source} source asset source
     * @param {JsAssetInfo} assetInfo extra asset information
     * @returns {void}
     */
    emitAsset(filename, source, assetInfo) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").emitAsset(filename, (0, createSource_1.createRawFromSource)(source), (0, util_1.toJsAssetInfo)(assetInfo));
    }
    deleteAsset(filename) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").deleteAsset(filename);
    }
    /**
     * Get an array of Asset
     *
     * See: [Compilation.getAssets](https://webpack.js.org/api/compilation-object/#getassets)
     * Source: [getAssets](https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L4448)
     */
    getAssets() {
        const assets = __classPrivateFieldGet(this, _Compilation_inner, "f").getAssets();
        return assets.map(asset => {
            return {
                ...asset,
                get source() {
                    return asset.source ? (0, createSource_1.createSourceFromRaw)(asset.source) : undefined;
                }
            };
        });
    }
    getAsset(name) {
        const asset = __classPrivateFieldGet(this, _Compilation_inner, "f").getAsset(name);
        if (!asset) {
            return;
        }
        return {
            ...asset,
            // @ts-expect-error
            source: (0, createSource_1.createSourceFromRaw)(asset.source)
        };
    }
    pushDiagnostic(severity, title, message) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").pushDiagnostic(severity, title, message);
    }
    __internal__pushNativeDiagnostics(diagnostics) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").pushNativeDiagnostics(diagnostics);
    }
    get errors() {
        const inner = __classPrivateFieldGet(this, _Compilation_inner, "f");
        return {
            push: (...errs) => {
                // compatible for javascript array
                for (let i = 0; i < errs.length; i++) {
                    const error = errs[i];
                    if ((0, util_1.isJsStatsError)(error)) {
                        __classPrivateFieldGet(this, _Compilation_inner, "f").pushDiagnostic("error", "Error", (0, util_1.concatErrorMsgAndStack)(error));
                    }
                    else if (typeof error === "string") {
                        __classPrivateFieldGet(this, _Compilation_inner, "f").pushDiagnostic("error", "Error", error);
                    }
                    else {
                        __classPrivateFieldGet(this, _Compilation_inner, "f").pushDiagnostic("error", error.name, (0, util_1.concatErrorMsgAndStack)(error));
                    }
                }
            },
            [Symbol.iterator]() {
                // TODO: this is obviously a bad design, optimize this after finishing angular prototype
                const errors = inner.getStats().getErrors();
                let index = 0;
                return {
                    next() {
                        if (index >= errors.length) {
                            return { done: true };
                        }
                        return {
                            value: errors[index++],
                            done: false
                        };
                    }
                };
            }
        };
    }
    get warnings() {
        const inner = __classPrivateFieldGet(this, _Compilation_inner, "f");
        return {
            // compatible for javascript array
            push: (...warns) => {
                // TODO: find a way to make JsStatsError be actual errors
                warns = this.hooks.processWarnings.call(warns);
                for (let i = 0; i < warns.length; i++) {
                    const warn = warns[i];
                    __classPrivateFieldGet(this, _Compilation_inner, "f").pushDiagnostic("warning", (0, util_1.isJsStatsError)(warn) ? "Warning" : warn.name, (0, util_1.concatErrorMsgAndStack)(warn));
                }
            },
            [Symbol.iterator]() {
                // TODO: this is obviously a bad design, optimize this after finishing angular prototype
                const warnings = inner.getStats().getWarnings();
                let index = 0;
                return {
                    next() {
                        if (index >= warnings.length) {
                            return { done: true };
                        }
                        return {
                            value: [warnings[index++]],
                            done: false
                        };
                    }
                };
            }
        };
    }
    getPath(filename, data = {}) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getPath(filename, data);
    }
    getPathWithInfo(filename, data = {}) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getPathWithInfo(filename, data);
    }
    getAssetPath(filename, data = {}) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getAssetPath(filename, data);
    }
    getAssetPathWithInfo(filename, data = {}) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getAssetPathWithInfo(filename, data);
    }
    getLogger(name) {
        if (!name) {
            throw new TypeError("Compilation.getLogger(name) called without a name");
        }
        let logEntries;
        return new Logger_1.Logger((type, args) => {
            if (typeof name === "function") {
                name = name();
                if (!name) {
                    throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
                }
            }
            let trace;
            switch (type) {
                case Logger_1.LogType.warn:
                case Logger_1.LogType.error:
                case Logger_1.LogType.trace:
                    trace = ErrorHelpers_1.default.cutOffLoaderExecution(new Error("Trace").stack)
                        .split("\n")
                        .slice(3);
                    break;
            }
            const logEntry = {
                time: Date.now(),
                type,
                // @ts-expect-error
                args,
                // @ts-expect-error
                trace
            };
            if (this.hooks.log.call(name, logEntry) === undefined) {
                if (logEntry.type === Logger_1.LogType.profileEnd) {
                    if (typeof console.profileEnd === "function") {
                        console.profileEnd(`[${name}] ${logEntry.args[0]}`);
                    }
                }
                if (logEntries === undefined) {
                    logEntries = this.logging.get(name);
                    if (logEntries === undefined) {
                        logEntries = [];
                        this.logging.set(name, logEntries);
                    }
                }
                logEntries.push(logEntry);
                if (logEntry.type === Logger_1.LogType.profile) {
                    if (typeof console.profile === "function") {
                        console.profile(`[${name}] ${logEntry.args[0]}`);
                    }
                }
            }
        }, (childName) => {
            if (typeof name === "function") {
                if (typeof childName === "function") {
                    return this.getLogger(() => {
                        if (typeof name === "function") {
                            name = name();
                            if (!name) {
                                throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
                            }
                        }
                        if (typeof childName === "function") {
                            childName = childName();
                            if (!childName) {
                                throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
                else {
                    return this.getLogger(() => {
                        if (typeof name === "function") {
                            name = name();
                            if (!name) {
                                throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
            }
            else {
                if (typeof childName === "function") {
                    return this.getLogger(() => {
                        if (typeof childName === "function") {
                            childName = childName();
                            if (!childName) {
                                throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
                else {
                    return this.getLogger(`${name}/${childName}`);
                }
            }
        });
    }
    get modules() {
        return this.__internal__getModules().map(item => (0, normalization_1.normalizeJsModule)(item));
    }
    // FIXME: This is not aligned with Webpack.
    get chunks() {
        return this.__internal__getChunks();
    }
    /**
     * Get the named chunks.
     *
     * Note: This is a proxy for webpack internal API, only method `get` is supported now.
     */
    get namedChunks() {
        return {
            get: (property) => {
                if (typeof property === "string") {
                    const chunk = __classPrivateFieldGet(this, _Compilation_inner, "f").getNamedChunk(property);
                    return chunk && Chunk_1.Chunk.__from_binding(chunk, __classPrivateFieldGet(this, _Compilation_inner, "f"));
                }
            }
        };
    }
    /**
     * Get the associated `modules` of an given chunk.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getAssociatedModules(chunk) {
        var _a;
        const modules = this.__internal__getModules();
        const moduleMap = new Map();
        for (const module of modules) {
            moduleMap.set(module.moduleIdentifier, module);
        }
        return (_a = chunk.modules) === null || _a === void 0 ? void 0 : _a.flatMap(chunkModule => {
            var _a;
            const jsModule = this.__internal__findJsModule((_a = chunkModule.issuer) !== null && _a !== void 0 ? _a : chunkModule.identifier, moduleMap);
            return {
                ...jsModule
                // dependencies: chunkModule.reasons?.flatMap(jsReason => {
                // 	let jsOriginModule = this.__internal__findJsModule(
                // 		jsReason.moduleIdentifier ?? "",
                // 		moduleMap
                // 	);
                // 	return {
                // 		...jsReason,
                // 		originModule: jsOriginModule
                // 	};
                // })
            };
        });
    }
    /**
     * Find a modules in an array.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__findJsModule(identifier, modules) {
        return modules.get(identifier);
    }
    /**
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getModules() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getModules();
    }
    /**
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getChunks() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f")
            .getChunks()
            .map(c => Chunk_1.Chunk.__from_binding(c, __classPrivateFieldGet(this, _Compilation_inner, "f")));
    }
    getStats() {
        return new Stats_1.Stats(this);
    }
    createChildCompiler(name, outputOptions, plugins) {
        const idx = this.childrenCounters[name] || 0;
        this.childrenCounters[name] = idx + 1;
        return this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);
    }
    rebuildModule(m, f) {
        this._rebuildModuleCaller.push([m.moduleIdentifier, f]);
    }
    /**
     * Get the `Source` of a given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in the future.
     *
     * @internal
     */
    __internal__getAssetSource(filename) {
        const rawSource = __classPrivateFieldGet(this, _Compilation_inner, "f").getAssetSource(filename);
        if (!rawSource) {
            return null;
        }
        return (0, createSource_1.createSourceFromRaw)(rawSource);
    }
    /**
     * Set the `Source` of an given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__setAssetSource(filename, source) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").setAssetSource(filename, (0, createSource_1.createRawFromSource)(source));
    }
    /**
     * Delete the `Source` of an given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__deleteAssetSource(filename) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").deleteAssetSource(filename);
    }
    /**
     * Get a list of asset filenames.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getAssetFilenames() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getAssetFilenames();
    }
    /**
     * Test if an asset exists.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__hasAsset(name) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").hasAsset(name);
    }
    __internal_getInner() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f");
    }
    seal() { }
    unseal() { }
    __internal_getProcessAssetsHookByStage(stage) {
        if (stage > Compilation.PROCESS_ASSETS_STAGE_REPORT) {
            this.pushDiagnostic("warning", "not supported process_assets_stage", `custom stage for process_assets is not supported yet, so ${stage} is fallback to Compilation.PROCESS_ASSETS_STAGE_REPORT(${Compilation.PROCESS_ASSETS_STAGE_REPORT}) `);
            stage = Compilation.PROCESS_ASSETS_STAGE_REPORT;
        }
        if (stage < Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL) {
            this.pushDiagnostic("warning", "not supported process_assets_stage", `custom stage for process_assets is not supported yet, so ${stage} is fallback to Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL(${Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL}) `);
            stage = Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL;
        }
        switch (stage) {
            case Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL:
                return this.hooks.processAssets.stageAdditional;
            case Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS:
                return this.hooks.processAssets.stagePreProcess;
            case Compilation.PROCESS_ASSETS_STAGE_DERIVED:
                return this.hooks.processAssets.stageDerived;
            case Compilation.PROCESS_ASSETS_STAGE_ADDITIONS:
                return this.hooks.processAssets.stageAdditions;
            case Compilation.PROCESS_ASSETS_STAGE_NONE:
                return this.hooks.processAssets.stageNone;
            case Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE:
                return this.hooks.processAssets.stageOptimize;
            case Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT:
                return this.hooks.processAssets.stageOptimizeCount;
            case Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY:
                return this.hooks.processAssets.stageOptimizeCompatibility;
            case Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE:
                return this.hooks.processAssets.stageOptimizeSize;
            case Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING:
                return this.hooks.processAssets.stageDevTooling;
            case Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE:
                return this.hooks.processAssets.stageOptimizeInline;
            case Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE:
                return this.hooks.processAssets.stageSummarize;
            case Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH:
                return this.hooks.processAssets.stageOptimizeHash;
            case Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER:
                return this.hooks.processAssets.stageOptimizeTransfer;
            case Compilation.PROCESS_ASSETS_STAGE_ANALYSE:
                return this.hooks.processAssets.stageAnalyse;
            case Compilation.PROCESS_ASSETS_STAGE_REPORT:
                return this.hooks.processAssets.stageReport;
            default:
                throw new Error("processAssets hook uses custom stage number is not supported.");
        }
    }
}
_Compilation_inner = new WeakMap();
Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL = -2000;
Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS = -1000;
Compilation.PROCESS_ASSETS_STAGE_DERIVED = -200;
Compilation.PROCESS_ASSETS_STAGE_ADDITIONS = -100;
Compilation.PROCESS_ASSETS_STAGE_NONE = 0;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE = 100;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT = 200;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY = 300;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE = 400;
Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING = 500;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE = 700;
Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE = 1000;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH = 2500;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER = 3000;
Compilation.PROCESS_ASSETS_STAGE_ANALYSE = 4000;
Compilation.PROCESS_ASSETS_STAGE_REPORT = 5000;
exports.Compilation = Compilation;
//# sourceMappingURL=Compilation.js.map
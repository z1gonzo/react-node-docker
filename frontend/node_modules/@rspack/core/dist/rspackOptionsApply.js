"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RspackOptionsApply = exports.applyEntryOptions = void 0;
const graceful_fs_1 = __importDefault(require("graceful-fs"));
const ResolveSwcPlugin_1 = require("./web/ResolveSwcPlugin");
const DefaultStatsFactoryPlugin_1 = require("./stats/DefaultStatsFactoryPlugin");
const DefaultStatsPrinterPlugin_1 = require("./stats/DefaultStatsPrinterPlugin");
const cleverMerge_1 = require("./util/cleverMerge");
const assert_1 = __importDefault(require("assert"));
const ignoreWarningsPlugin_1 = __importDefault(require("./lib/ignoreWarningsPlugin"));
const EntryOptionPlugin_1 = __importDefault(require("./lib/EntryOptionPlugin"));
const builtin_plugin_1 = require("./builtin-plugin");
const util_1 = require("./util");
function applyEntryOptions(compiler, options) {
    var _a;
    if (!options.experiments.rspackFuture.disableApplyEntryLazily) {
        (0, util_1.deprecatedWarn)(`You are depending on ${(0, util_1.termlink)("apply entry lazily", "https://rspack.dev/config/experiments.html#experimentsrspackfuturedisableapplyentrylazily")}, this behavior has been deprecated, you can setup 'experiments.rspackFuture.disableApplyEntryLazily = true' to disable this behavior, and this will be enabled by default in v0.5`);
    }
    if (compiler.parentCompilation === undefined) {
        if (options.experiments.rspackFuture.disableApplyEntryLazily) {
            new EntryOptionPlugin_1.default().apply(compiler);
        }
        else {
            EntryOptionPlugin_1.default.applyEntryOption(compiler, compiler.context, options.entry);
        }
        if ((_a = options.devServer) === null || _a === void 0 ? void 0 : _a.hot) {
            // break in 0.5
            new compiler.webpack.HotModuleReplacementPlugin().apply(compiler);
        }
    }
}
exports.applyEntryOptions = applyEntryOptions;
class RspackOptionsApply {
    constructor() { }
    process(options, compiler) {
        var _a, _b;
        (0, assert_1.default)(options.output.path, "options.output.path should have value after `applyRspackOptionsDefaults`");
        compiler.outputPath = options.output.path;
        compiler.name = options.name;
        compiler.outputFileSystem = graceful_fs_1.default;
        if (options.externals) {
            (0, assert_1.default)(options.externalsType, "options.externalsType should have value after `applyRspackOptionsDefaults`");
            new builtin_plugin_1.ExternalsPlugin(options.externalsType, options.externals).apply(compiler);
        }
        if (options.externalsPresets.node) {
            new builtin_plugin_1.NodeTargetPlugin().apply(compiler);
        }
        if (options.externalsPresets.electronMain) {
            new builtin_plugin_1.ElectronTargetPlugin("main").apply(compiler);
        }
        if (options.externalsPresets.electronPreload) {
            new builtin_plugin_1.ElectronTargetPlugin("preload").apply(compiler);
        }
        if (options.externalsPresets.electronRenderer) {
            new builtin_plugin_1.ElectronTargetPlugin("renderer").apply(compiler);
        }
        if (options.externalsPresets.electron &&
            !options.externalsPresets.electronMain &&
            !options.externalsPresets.electronPreload &&
            !options.externalsPresets.electronRenderer) {
            new builtin_plugin_1.ElectronTargetPlugin().apply(compiler);
        }
        if (options.externalsPresets.web ||
            options.externalsPresets.webAsync ||
            (options.externalsPresets.node && options.experiments.css)) {
            new builtin_plugin_1.HttpExternalsRspackPlugin(!!options.experiments.css, !!options.externalsPresets.webAsync).apply(compiler);
        }
        new builtin_plugin_1.ChunkPrefetchPreloadPlugin().apply(compiler);
        if (typeof options.output.chunkFormat === "string") {
            switch (options.output.chunkFormat) {
                case "array-push": {
                    new builtin_plugin_1.ArrayPushCallbackChunkFormatPlugin().apply(compiler);
                    break;
                }
                case "commonjs": {
                    new builtin_plugin_1.CommonJsChunkFormatPlugin().apply(compiler);
                    break;
                }
                case "module": {
                    new builtin_plugin_1.ModuleChunkFormatPlugin().apply(compiler);
                    break;
                }
                default:
                    throw new Error("Unsupported chunk format '" + options.output.chunkFormat + "'.");
            }
        }
        if (options.output.enabledChunkLoadingTypes &&
            options.output.enabledChunkLoadingTypes.length > 0) {
            for (const type of options.output.enabledChunkLoadingTypes) {
                new builtin_plugin_1.EnableChunkLoadingPlugin(type).apply(compiler);
            }
        }
        if (options.output.enabledWasmLoadingTypes &&
            options.output.enabledWasmLoadingTypes.length > 0) {
            for (const type of options.output.enabledWasmLoadingTypes) {
                new builtin_plugin_1.EnableWasmLoadingPlugin(type).apply(compiler);
            }
        }
        if (options.output.enabledLibraryTypes &&
            options.output.enabledLibraryTypes.length > 0) {
            for (const type of options.output.enabledLibraryTypes) {
                new builtin_plugin_1.EnableLibraryPlugin(type).apply(compiler);
            }
        }
        const runtimeChunk = options.optimization
            .runtimeChunk;
        if (runtimeChunk) {
            Object.entries(options.entry).forEach(([entryName, value]) => {
                if (value.runtime === undefined) {
                    value.runtime = runtimeChunk.name({ name: entryName });
                }
            });
        }
        if (options.devtool) {
            if (options.devtool.includes("source-map")) {
                const hidden = options.devtool.includes("hidden");
                const inline = options.devtool.includes("inline");
                const evalWrapped = options.devtool.includes("eval");
                const cheap = options.devtool.includes("cheap");
                // TODO: const moduleMaps = options.devtool.includes("module");
                const noSources = options.devtool.includes("nosources");
                const Plugin = evalWrapped
                    ? builtin_plugin_1.EvalSourceMapDevToolPlugin
                    : builtin_plugin_1.SourceMapDevToolPlugin;
                new Plugin({
                    filename: inline ? null : options.output.sourceMapFilename,
                    append: hidden ? false : undefined,
                    columns: cheap ? false : true,
                    noSources: noSources,
                    namespace: options.output.devtoolNamespace
                }).apply(compiler);
            }
        }
        new builtin_plugin_1.JavascriptModulesPlugin().apply(compiler);
        new builtin_plugin_1.JsonModulesPlugin().apply(compiler);
        new builtin_plugin_1.AssetModulesPlugin().apply(compiler);
        if (options.experiments.asyncWebAssembly) {
            new builtin_plugin_1.AsyncWebAssemblyModulesPlugin().apply(compiler);
        }
        if (options.experiments.rspackFuture.disableApplyEntryLazily) {
            applyEntryOptions(compiler, options);
        }
        (0, assert_1.default)(options.context, "options.context should have value after `applyRspackOptionsDefaults`");
        compiler.hooks.entryOption.call(options.context, options.entry);
        new builtin_plugin_1.RuntimePlugin().apply(compiler);
        new builtin_plugin_1.InferAsyncModulesPlugin().apply(compiler);
        new builtin_plugin_1.DataUriPlugin().apply(compiler);
        new builtin_plugin_1.FileUriPlugin().apply(compiler);
        new builtin_plugin_1.EnsureChunkConditionsPlugin().apply(compiler);
        if (options.optimization.mergeDuplicateChunks) {
            new builtin_plugin_1.MergeDuplicateChunksPlugin().apply(compiler);
        }
        if (options.builtins.devFriendlySplitChunks) {
            options.optimization.splitChunks = undefined;
        }
        if ((_a = options.experiments.rspackFuture) === null || _a === void 0 ? void 0 : _a.newTreeshaking) {
            if (options.optimization.sideEffects) {
                new builtin_plugin_1.SideEffectsFlagPlugin( /* options.optimization.sideEffects === true */).apply(compiler);
            }
            if (options.optimization.providedExports) {
                new builtin_plugin_1.FlagDependencyExportsPlugin().apply(compiler);
            }
            if (options.optimization.usedExports) {
                new builtin_plugin_1.FlagDependencyUsagePlugin(options.optimization.usedExports === "global").apply(compiler);
            }
        }
        if (options.optimization.mangleExports) {
            new builtin_plugin_1.MangleExportsPlugin(options.optimization.mangleExports !== "size").apply(compiler);
        }
        if (options.optimization.splitChunks &&
            options.experiments.newSplitChunks === false) {
            new builtin_plugin_1.OldSplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
        }
        else if (options.optimization.splitChunks) {
            new builtin_plugin_1.SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
        }
        // TODO: inconsistent: the plugin need to be placed after SplitChunksPlugin
        if (options.optimization.removeEmptyChunks) {
            new builtin_plugin_1.RemoveEmptyChunksPlugin().apply(compiler);
        }
        if (options.optimization.realContentHash) {
            new builtin_plugin_1.RealContentHashPlugin().apply(compiler);
        }
        const moduleIds = options.optimization.moduleIds;
        if (moduleIds) {
            switch (moduleIds) {
                case "named": {
                    new builtin_plugin_1.NamedModuleIdsPlugin().apply(compiler);
                    break;
                }
                case "deterministic": {
                    new builtin_plugin_1.DeterministicModuleIdsPlugin().apply(compiler);
                    break;
                }
                default:
                    throw new Error(`moduleIds: ${moduleIds} is not implemented`);
            }
        }
        const chunkIds = options.optimization.chunkIds;
        if (chunkIds) {
            switch (chunkIds) {
                case "named": {
                    new builtin_plugin_1.NamedChunkIdsPlugin().apply(compiler);
                    break;
                }
                case "deterministic": {
                    new builtin_plugin_1.DeterministicChunkIdsPlugin().apply(compiler);
                    break;
                }
                default:
                    throw new Error(`chunkIds: ${chunkIds} is not implemented`);
            }
        }
        if (options.optimization.nodeEnv) {
            new builtin_plugin_1.DefinePlugin({
                "process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
            }).apply(compiler);
        }
        const { minimize, minimizer } = options.optimization;
        if (minimize && minimizer) {
            for (const item of minimizer) {
                if (typeof item === "function") {
                    item.call(compiler, compiler);
                }
                else if (item !== "..." && item) {
                    item.apply(compiler);
                }
            }
        }
        new builtin_plugin_1.WarnCaseSensitiveModulesPlugin().apply(compiler);
        if ((_b = options.devServer) === null || _b === void 0 ? void 0 : _b.hot) {
            options.output.strictModuleErrorHandling = true;
        }
        new ResolveSwcPlugin_1.ResolveSwcPlugin().apply(compiler);
        new builtin_plugin_1.WorkerPlugin(options.output.workerChunkLoading, options.output.workerWasmLoading, options.output.module, options.output.workerPublicPath).apply(compiler);
        new DefaultStatsFactoryPlugin_1.DefaultStatsFactoryPlugin().apply(compiler);
        new DefaultStatsPrinterPlugin_1.DefaultStatsPrinterPlugin().apply(compiler);
        if (options.ignoreWarnings && options.ignoreWarnings.length > 0) {
            new ignoreWarningsPlugin_1.default(options.ignoreWarnings).apply(compiler);
        }
        compiler.hooks.afterPlugins.call(compiler);
        if (!compiler.inputFileSystem) {
            throw new Error("No input filesystem provided");
        }
        compiler.resolverFactory.hooks.resolveOptions
            .for("normal")
            .tap("RspackOptionsApply", resolveOptions => {
            resolveOptions = (0, cleverMerge_1.cleverMerge)(options.resolve, resolveOptions);
            resolveOptions.fileSystem = compiler.inputFileSystem;
            return resolveOptions;
        });
        compiler.resolverFactory.hooks.resolveOptions
            .for("context")
            .tap("RspackOptionsApply", resolveOptions => {
            resolveOptions = (0, cleverMerge_1.cleverMerge)(options.resolve, resolveOptions);
            resolveOptions.fileSystem = compiler.inputFileSystem;
            resolveOptions.resolveToContext = true;
            return resolveOptions;
        });
        compiler.hooks.afterResolvers.call(compiler);
    }
}
exports.RspackOptionsApply = RspackOptionsApply;
//# sourceMappingURL=rspackOptionsApply.js.map
import { Compilation, Assets } from "..";
import * as tapable from "tapable";
export declare const createFakeProcessAssetsHook: (compilation: Compilation) => {
    name: string;
    tap: (options: string | {
        name: string;
        stage?: number | undefined;
    }, fn: (assets: Assets) => void) => void;
    tapAsync: (options: string | {
        name: string;
        stage?: number | undefined;
    }, fn: (assets: Assets, cb: tapable.InnerCallback<Error, void>) => void) => void;
    tapPromise: (options: string | {
        name: string;
        stage?: number | undefined;
    }, fn: (assets: Assets) => Promise<void>) => void;
    stageAdditional: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stagePreProcess: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageDerived: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageAdditions: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageNone: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageOptimize: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageOptimizeCount: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageOptimizeCompatibility: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageOptimizeSize: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageDevTooling: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageOptimizeInline: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageSummarize: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageOptimizeHash: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageOptimizeTransfer: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageAnalyse: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
    stageReport: tapable.AsyncSeriesHook<Assets, tapable.UnsetAdditionalOptions>;
};
export type FakeHook<T> = T & {
    _fakeHook: true;
};
export declare const createFakeHook: <T extends object>(fakeHook: T) => FakeHook<T>;
export declare const createProcessAssetsHook: <T>(processAssetsHooks: ReturnType<typeof createFakeProcessAssetsHook>, name: string, stage: number, getArgs: () => tapable.AsArray<T>) => FakeHook<Pick<tapable.AsyncSeriesHook<T, tapable.UnsetAdditionalOptions>, "name" | "tap" | "tapAsync" | "tapPromise">>;
export declare function createFakeCompilationDependencies(getDeps: () => string[], addDeps: (deps: string[]) => void): {
    [Symbol.iterator](): Generator<string, void, unknown>;
    has(dep: string): boolean;
    add: (dep: string) => void;
    addAll: (deps: Iterable<string>) => void;
};
//# sourceMappingURL=fake.d.ts.map
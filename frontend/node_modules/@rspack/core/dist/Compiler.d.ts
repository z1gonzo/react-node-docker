/// <reference types="node" />
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/Compiler.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
import type * as binding from "@rspack/binding";
import * as tapable from "tapable";
import { Callback } from "tapable";
import type { WatchOptions } from "watchpack";
import { EntryNormalized, OutputNormalized, RspackOptionsNormalized, RspackPluginInstance } from "./config";
import { RuleSetCompiler } from "./RuleSetCompiler";
import { Stats } from "./Stats";
import { Compilation, CompilationParams } from "./Compilation";
import { ContextModuleFactory } from "./ContextModuleFactory";
import ResolverFactory from "./ResolverFactory";
import Cache from "./lib/Cache";
import CacheFacade from "./lib/CacheFacade";
import { Logger } from "./logging/Logger";
import { NormalModuleFactory } from "./NormalModuleFactory";
import { WatchFileSystem } from "./util/fs";
import { Watching } from "./Watching";
import { FileSystemInfoEntry } from "./FileSystemInfo";
declare class Compiler {
    #private;
    webpack: typeof import("./rspack").rspack & typeof import("./exports") & {
        rspack: typeof import("./rspack").rspack & typeof import("./exports") & any;
        webpack: typeof import("./rspack").rspack & typeof import("./exports") & any;
    };
    compilation: Compilation;
    builtinPlugins: binding.BuiltinPlugin[];
    root: Compiler;
    running: boolean;
    idle: boolean;
    resolverFactory: ResolverFactory;
    infrastructureLogger: any;
    watching?: Watching;
    outputPath: string;
    name?: string;
    inputFileSystem: any;
    outputFileSystem: typeof import("fs");
    ruleSet: RuleSetCompiler;
    watchFileSystem: WatchFileSystem;
    intermediateFileSystem: any;
    watchMode: boolean;
    context: string;
    modifiedFiles?: ReadonlySet<string>;
    cache: Cache;
    compilerPath: string;
    removedFiles?: ReadonlySet<string>;
    fileTimestamps?: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>;
    contextTimestamps?: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>;
    hooks: {
        done: tapable.AsyncSeriesHook<Stats>;
        afterDone: tapable.SyncHook<Stats>;
        compilation: tapable.SyncHook<[Compilation, CompilationParams]>;
        thisCompilation: tapable.SyncHook<[Compilation, CompilationParams]>;
        invalid: tapable.SyncHook<[string | null, number]>;
        compile: tapable.SyncHook<[any]>;
        normalModuleFactory: tapable.SyncHook<NormalModuleFactory>;
        contextModuleFactory: tapable.SyncHook<ContextModuleFactory>;
        initialize: tapable.SyncHook<[]>;
        shouldEmit: tapable.SyncBailHook<[Compilation], undefined>;
        infrastructureLog: tapable.SyncBailHook<[string, string, any[]], true>;
        beforeRun: tapable.AsyncSeriesHook<[Compiler]>;
        run: tapable.AsyncSeriesHook<[Compiler]>;
        emit: tapable.AsyncSeriesHook<[Compilation]>;
        assetEmitted: tapable.AsyncSeriesHook<[string, any]>;
        afterEmit: tapable.AsyncSeriesHook<[Compilation]>;
        failed: tapable.SyncHook<[Error]>;
        shutdown: tapable.AsyncSeriesHook<[]>;
        watchRun: tapable.AsyncSeriesHook<[Compiler]>;
        watchClose: tapable.SyncHook<[]>;
        environment: tapable.SyncHook<[]>;
        afterEnvironment: tapable.SyncHook<[]>;
        afterPlugins: tapable.SyncHook<[Compiler]>;
        afterResolvers: tapable.SyncHook<[Compiler]>;
        make: tapable.AsyncParallelHook<[Compilation]>;
        beforeCompile: tapable.AsyncSeriesHook<any>;
        afterCompile: tapable.AsyncSeriesHook<[Compilation]>;
        finishModules: tapable.AsyncSeriesHook<[any]>;
        finishMake: tapable.AsyncSeriesHook<[Compilation]>;
        entryOption: tapable.SyncBailHook<[string, EntryNormalized], any>;
    };
    options: RspackOptionsNormalized;
    parentCompilation?: Compilation;
    constructor(context: string, options: RspackOptionsNormalized);
    /**
     * @param {string} name cache name
     * @returns {CacheFacade} the cache facade instance
     */
    getCache(name: string): CacheFacade;
    createChildCompiler(compilation: Compilation, compilerName: string, compilerIndex: number, outputOptions: OutputNormalized, plugins: RspackPluginInstance[]): Compiler;
    runAsChild(callback: any): void;
    isChild(): boolean;
    getInfrastructureLogger(name: string | Function): Logger;
    run(callback: Callback<Error, Stats>): void;
    build(callback: (error: Error | null) => void): void;
    rebuild(modifiedFiles?: ReadonlySet<string>, removedFiles?: ReadonlySet<string>, callback?: (error: Error | null) => void): void;
    compile(callback: Callback<Error, Compilation>): void;
    watch(watchOptions: WatchOptions, handler: Callback<Error, Stats>): Watching;
    purgeInputFileSystem(): void;
    close(callback: (error?: Error | null) => void): void;
    getAsset(name: string): Buffer | null;
    __internal__registerBuiltinPlugin(plugin: binding.BuiltinPlugin): void;
}
export { Compiler };
//# sourceMappingURL=Compiler.d.ts.map